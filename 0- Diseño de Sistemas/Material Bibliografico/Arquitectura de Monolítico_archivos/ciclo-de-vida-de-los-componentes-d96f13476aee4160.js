(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[407],{50061:function(e,o,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/blog/es/react/ciclo-de-vida-de-los-componentes",function(){return n(26967)}])},79611:function(e,o,n){"use strict";var a=n(85893);n(67294);var s=n(98683);let r=e=>(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(s.Z,{...e,showLineNumbers:!0,children:e.children}),(0,a.jsx)("br",{})]});o.Z=r},92838:function(e,o,n){"use strict";var a=n(85893),s=n(25675),r=n.n(s);n(67294);let d=e=>(0,a.jsxs)("article",{className:"tip flex gap-4 m-0 md:m-10 p-4",style:{borderLeft:"2px solid var(--color-red-light)"},children:[(0,a.jsx)(r(),{width:"64",height:"64",src:(()=>{switch(e.type){case"tip":default:return"/icons/tip.png";case"concepto":return"/icons/concepto.png"}})(),alt:"tip",className:"icon w-16 h-16 "}),(0,a.jsxs)("div",{children:[(0,a.jsx)("p",{className:"mb-4",children:(0,a.jsx)("strong",{children:e.title})}),(0,a.jsx)("div",{className:"m-0",children:e.children||e.message})]})]});o.Z=d},45734:function(e,o,n){"use strict";var a=n(85893);n(67294);var s=n(41664),r=n.n(s);let d=e=>(0,a.jsx)("article",{className:"book-banner",children:(e.lang,(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)("div",{children:(0,a.jsx)("img",{className:"book-img d-none d-md-block responsive lazy","data-src":"/books/aplicaciones-reactivas.png",alt:"Aplicaciones reactivas con React, NodeJS & MongoDB"})}),(0,a.jsxs)("div",{children:[(0,a.jsxs)("p",{className:"mb-4",children:["Todo lo que acabas de ver en este art\xedculo es solo una peque\xf1a parte del libro ",(0,a.jsx)(r(),{href:"/books/aplicaciones-reactivas-con-react-nodejs-mongodb/es",children:"Aplicaciones reactivas con React, NodeJS & MongoDB"}),", El libro m\xe1s completo en espa\xf1ol para aprender a crear aplicaciones web completas con las tecnolog\xedas m\xe1s potentes de la actualidad, desde el Frontend con React, hasta el Backend con un poderoso API REST con NodeJS y Express y persistiendo todo en MongoDB. te invito a que veas mi libro:"]}),(0,a.jsx)(r(),{href:"/books/aplicaciones-reactivas-con-react-nodejs-mongodb/es",legacyBehavior:!0,children:(0,a.jsx)("a",{className:"btn btn-block btn-pink block text-center rounded-md",children:"Ver libro"})})]})]}))});o.Z=d},26967:function(e,o,n){"use strict";n.r(o);var a=n(85893);n(67294);var s=n(25675),r=n.n(s),d=n(9008),t=n.n(d),i=n(97518),l=n(45734),c=n(92838),p=n(79611);let u=e=>(0,a.jsxs)("div",{className:"",children:[(0,a.jsx)(t(),{children:(0,a.jsx)("title",{children:"Ciclo de vida de los componentes"})}),(0,a.jsx)(i.Z,{product:"react",children:(0,a.jsxs)("main",{children:[(0,a.jsx)("h1",{children:"Ciclo de vida de los componentes"}),(0,a.jsx)("p",{children:"El ciclo de vida (life cycle) de un componente, representa las etapas por las que un componente pasa durante toda su vida, desde la creaci\xf3n hasta que es destruido. Conocer el ciclo de vida de un componente es muy importante debido a que nos permite saber c\xf3mo es que un componente se comporta durante todo su tiempo de vida y nos permite prevenir la gran mayor\xeda de los errores que se provocan en tiempo de ejecuci\xf3n."}),(0,a.jsx)("p",{children:"Hasta el momento hemos hablado de muchas caracter\xedsticas de React, como lo son las props, los estados (state), el shadow dom y controles, pero poco hemos hablado acerca de c\xf3mo React administra los componentes. Por lo que en esta unidad nos centraremos exclusivamente en esto."}),(0,a.jsx)("p",{children:"Para comprender el ciclo de vida de los componentes es importante hablar un poco de la historia de React y como este ha venido evolucionando y madurando su ciclo de vida, en este contexto, es importante mencionar que desde su nacimiento, React ha cambiado ligeramente el clico de vida de los componentes, desaconsejando y agregando nuevos m\xe9todos, es por ello que me gustar\xeda mostrar primero que nada el ciclo de vida de React hasta la versi\xf3n 16.2:"}),(0,a.jsxs)("figure",{children:[(0,a.jsx)(r(),{width:"552",height:"502",src:"/figures/react/ciclo-de-vida-obsoleto.png",alt:"Ciclo de vida de los componentes en React."}),(0,a.jsx)("figcaption",{children:"Ciclo de vida de los componentes en React."})]}),(0,a.jsx)("p",{children:"En la imagen anterior puedes ver todos los m\xe9todos del ciclo de vida de los componentes que funcionaban hasta la versi\xf3n 16.2, donde podemos apreciar de color verde los m\xe9todos que siguen vigentes hasta el d\xeda de hoy y en rojo los m\xe9todos que se han desaconsejado su uso (deprecados). Si bien los m\xe9todos deprecados siguen funcionando en todas las versiones de React 16.x, est\xe1n programados para ser removidos en la versi\xf3n 17, por lo que hay que tener cuidado de utilizarlos."}),(0,a.jsxs)("p",{children:["Hoy en d\xeda los m\xe9todos deprecados pueden seguir siendo utilizados con su nombre original, sin embargo, siempre nos arrojar\xe1 warnings en la consola, a menos que renombremos los m\xe9todos con el prefijo ",(0,a.jsx)("code",{children:"UNSAFE_"}),", por ejemplo ",(0,a.jsx)("code",{children:"UNSAFE_componentWillMount"}),", ",(0,a.jsx)("code",{children:"UNSAFE_componentWillReceiveProps"})," y ",(0,a.jsx)("code",{children:"UNSAFE_componentWillUpdate"}),". Finalmente, se espera que para la versi\xf3n 17 de React, solo est\xe9n disponibles estos m\xe9todos con el prefijo ",(0,a.jsx)("code",{children:"UNSAFE_"}),", por lo que mi consejo es, no utilizar nunca m\xe1s estos m\xe9todos en desarrollos nuevos, pues est\xe1n programados para ser removidos por completo en versiones posteriores."]}),(0,a.jsx)("p",{children:"Vamos a tratar de mencionar para que sirve todos estos m\xe9todos, incluso los desaconsejados, con la intenci\xf3n de que si los ves en alg\xfan proyecto antiguo sepas que hacen, pero no nos centraremos de lleno en entender como funcionaba todo este ciclo de vida, pues consideramos que es algo que ya va de salida y no vale la pena invertir mucho tiempo en ello."}),(0,a.jsx)("p",{children:"Una vez que ya hablamos del ciclo de vida antiguo de React, pasaremos a la nueva configuraci\xf3n del ciclo de vida que est\xe1 disponible a partir de la versi\xf3n 16.3:"}),(0,a.jsxs)("figure",{children:[(0,a.jsx)(r(),{width:"552",height:"284",src:"/figures/react/ciclo-de-vida-nuevo.png",alt:"Ciclo de vida de los componentes en React."}),(0,a.jsx)("figcaption",{children:"Ciclo de vida de los componentes en React."})]}),(0,a.jsx)("p",{children:"En la imagen anterior podemos ver la nueva configuraci\xf3n del ciclo de vida, marcando en amarillo los nuevos m\xe9todos que son agregados a partir de la versi\xf3n 16.3."}),(0,a.jsx)("p",{children:"Hemos tratado de ordenar los m\xe9todos del ciclo de vida seg\xfan el orden en el que se ejecutan, sin embargo, no siempre se ejecutar\xe1n todos los m\xe9todos o incluso, habr\xe1 otros que se ejecuten m\xe1s de una vez, por lo que la imagen anterior representa el flujo de un componente que se monta, actualiza (una sola vez) y finalmente de desmonta."}),(0,a.jsx)("p",{children:"En las siguientes secciones explicaremos con detalle para que sirve cada m\xe9todo de forma individual y seguido explicaremos como interviene cada m\xe9todo en los 3 escenarios posibles por los que puedes pasar un componente, es decir, Montaje, Actualizaci\xf3n y Desmontaje."}),(0,a.jsx)("p",{children:"Para comprender el ciclo de vida de los componentes es super importante entender 3 conceptos fundamentes:"}),(0,a.jsx)(c.Z,{title:"Nuevo concepto: Montaje",children:(0,a.jsx)("p",{children:"En React, el montaje es el proceso por medio del cual el componente es construido y renderizado en pantalla por primera vez, por lo tanto, se considera montado solo cuando el componente ya es visible en pantalla y ya es parte del Document Object Model (DOM). "})}),(0,a.jsx)(c.Z,{title:"Nuevo concepto: Actualizaci\xf3n",children:(0,a.jsx)("p",{children:"En React, la actualizaci\xf3n es el proceso por medio del cual un componte ya montado es actualizado, ya sea por cambiar el state o las props."})}),(0,a.jsx)(c.Z,{title:"Nuevo concepto: Desmontaje",children:(0,a.jsx)("p",{children:"En React, el desmontaje es el proceso por medio del cual un componte es destruido y finalmente removido del Document Object Model (DOM), lo que implica que no sea visible en pantalla."})}),(0,a.jsx)("p",{children:"Dicho lo anterior, podemos ver que m\xe9todos del ciclo de vida se ejecutan en cada etapa:"}),(0,a.jsxs)("figure",{children:[(0,a.jsx)(r(),{width:"1090",height:"627",src:"/figures/react/ciclo-de-vida-por-fase.png",alt:"Ciclo de vida de los componentes en React."}),(0,a.jsx)("figcaption",{children:"Ciclo de vida de los componentes en React."})]}),(0,a.jsx)("h2",{children:"El Constructor"}),(0,a.jsxs)("p",{children:["Antes que nada, me gustar\xeda aclarar que el constructor no es como tal un m\xe9todo del ciclo de vida, sin embargo, lo quise agregar debido a que a partir de la versi\xf3n 16.3 toma un mayor protagonismo al ser deprecado el m\xe9todo ",(0,a.jsx)("code",{children:"componentWillMount"}),"."]}),(0,a.jsxs)("p",{children:["Como vamos a ver en el siguiente punto, el m\xe9todo ",(0,a.jsx)("code",{children:"componentWillMount"})," se ejecutaba justo antes de montar el componente, por lo que se utiliza para inicializar el componente, como llamar alg\xfan servicio o inicializar el status, sin embargo, a partir de la versi\xf3n 16.3 de React el m\xe9todo ",(0,a.jsx)("code",{children:"componentWillMount"})," ha sido deprecado, por lo que se aconseja utilizar el constructor para inicializar el componente."]}),(0,a.jsx)("p",{children:"Si bien no es necesario que todos los componentes definan el constructor, es importante hacer algunas aclaraciones para evitar posibles errores en tiempo de ejecuci\xf3n, as\xed que lo analizaremos con un ejemplo:"}),(0,a.jsx)(p.Z,{language:"javascript",children:'import React from \'react\'\nimport Image from \'next/image\'  \nimport { render } from \'react-dom\'  \nimport "core-js/stable";  \nimport "regenerator-runtime/runtime";  \n    \nclass App extends React.Component {  \n    constructor(args){  \n        super(args)  \n        APIInvoke.invokeGET("/tweets", response => {  \n            console.log("api response =>")  \n            this.setState(response.body)  \n        }, error => {  \n    \n        })  \n    }  \n    \n    \n    render() {  \n        console.log("render =>")  \n        return (  \n            <h1>Hello World</h1>  \n        )  \n    }  \n}  \nrender(<App />, document.getElementById(\'root\'));    '}),(0,a.jsx)("p",{children:"Lo primero que tenemos que tomar en cuenta es que el constructor recibe como par\xe1metro las propiedades, por lo que es indispensable agregar dicho par\xe1metro. Por otra parte, es super importante que la primera l\xednea del cuerpo del constructor mande llamar al constructor de la super clase mediante super(args), de lo contrario, el componente no ser\xe1 inicializado correctamente y las props no estar\xe1n disponibles en tiempo de ejecuci\xf3n."}),(0,a.jsx)(c.Z,{title:"Error com\xfan",children:(0,a.jsx)("p",{children:"No inicializar el constructor de la super clase con super(args) puede provocar que las props no est\xe9n disponibles en tiempo de ejecuci\xf3n."})}),(0,a.jsxs)("p",{children:["Los siguiente a tomar en cuenta es que cualquier llamada a un servicio externo o cualquier operaci\xf3n que sea as\xedncrona, dar\xe1 como resultado que el componente sea renderizado antes de obtener los resultados de esa llamada, por ejemplo, en la clase anterior, hacemos una llamada al API REST mediante la clase ",(0,a.jsx)("code",{children:"APIInvoke"}),", y luego en el m\xe9todo render imprimimos el mensaje “render” en pantalla. "]}),(0,a.jsx)("p",{children:"Un programador inexperto esperar\xeda que el m\xe9todo render sea llamado justo despu\xe9s de que el API response, sin embargo, al ser una llamada as\xedncrona, el constructor termina y una vez terminado, se ejecuta la llamada al API, lo que da como resultado que veamos en el log del navegador la siguiente salida:"}),(0,a.jsx)(p.Z,{language:"javascript",children:"1.	render =>\n2.	API response =>  "}),(0,a.jsx)("p",{children:"Esto es importante porque hay que ser precavidos en el m\xe9todo render y no esperar que los valores del estado est\xe9n inicializados previo al primer renderizado del componente."}),(0,a.jsx)(c.Z,{title:"Importante",children:(0,a.jsx)("p",{children:"El constructor solo se ejecuta una sola vez durante todo el ciclo de vida de un componente."})}),(0,a.jsx)("h2",{children:"Function getDerivedStateFromProps"}),(0,a.jsxs)("p",{children:["La funci\xf3n ",(0,a.jsx)("code",{children:"getDerivedStateFromProps"})," se utiliza en casos muy raros donde el estado del componte depende de las props, de tal forma que este m\xe9todo permite actualizar el estado en funci\xf3n de las propiedades y retornar un nuevo estado."]}),(0,a.jsx)("p",{children:"Este m\xe9todo recibe como par\xe1metro el estado y las propiedades, y deber\xe1 retornar un objeto, el cual ser\xe1 establecido como el nuevo estado del componente, o retornar null para indicar que se conserva el estado actual sin aplicarle ning\xfan cambio. "}),(0,a.jsx)(p.Z,{language:"javascript",children:"static getDerivedStateFromProps(props, state){  \n    if (props.client.id != state.cliente.id) {  \n        return {  \n            ...state,  \n            client: props.client  \n        }  \n    }  \n    return null  \n} "}),(0,a.jsx)("p",{children:"Observa que este es el \xfanico m\xe9todo del ciclo de vida que es est\xe1tico, lo que quiere decir que no tiene acceso a la instancia del componente, por lo tanto, todo lo relacionado al DOM no estar\xe1 disponible."}),(0,a.jsx)(c.Z,{title:"Importante",children:(0,a.jsx)("p",{children:"La funci\xf3n getDerivedStateFromProps se ejecuta cada vez que las propiedades del componente cambien y se ejecuta justo despu\xe9s del constructor y justo antes del render, tanto en el montaje como las actualizaciones"})}),(0,a.jsx)(c.Z,{title:"Function componentWillMount (deprecated)",children:(0,a.jsx)("p",{children:"La funci\xf3n componentWillMount() se ejecuta antes de que el componente sea montado y antes de la funci\xf3n render(). Se utiliza por lo general para realizar la carga de datos desde el servidor o para realizar una inicializaci\xf3n s\xedncrona del estado. "})}),(0,a.jsx)("p",{children:"Esta funci\xf3n no recibe ning\xfan par\xe1metro y se ve de la siguiente manera:"}),(0,a.jsx)(p.Z,{language:"javascript",children:"UNSAFE_componentWillMount(){  \n    //Any action  \n} "}),(0,a.jsxs)("p",{children:["En este punto, los elementos del componente no podr\xe1n ser accedidos por medio del DOM, pues a\xfan no han sido creados, esto quiere decir que si buscamos un elemento en el DOM mediante ",(0,a.jsx)("code",{children:"document.getElementById(“id”)"}),", este no existir\xe1 porque en este punto no ha sido enviado al DOM."]}),(0,a.jsx)(c.Z,{title:"Importante",children:(0,a.jsx)("p",{children:"Recordemos que este m\xe9todo fue deprecado a partir de React 16.3, por lo que no deber\xedamos utilizarlo m\xe1s, sin embargo, si se llegara a utilizar, deber\xe1 de llevar el prefijo UNSAFE_. "})}),(0,a.jsx)(c.Z,{title:"Importante",children:(0,a.jsx)("p",{children:"La funci\xf3n componentWillMount solo se ejecuta una sola vez durante todo el ciclo de vida de un componente."})}),(0,a.jsx)("h2",{children:"Function render"}),(0,a.jsxs)("p",{children:["El m\xe9todo ",(0,a.jsx)("code",{children:"render()"})," es el \xfanico de todos los m\xe9todos del ciclo de vida que es obligatorio, pues es el que se encarga de definir como el componente deber\xe1 ser renderizado en pantalla, por lo que como resultado deber\xe1 retornar cualquiera de los siguientes valores:"]}),(0,a.jsxs)("ul",{children:[(0,a.jsxs)("li",{children:[(0,a.jsx)("strong",{children:"Elementos de React"}),": Son elementos creados normalmente con ayuda de JSX, como por ejemplo un ",(0,a.jsx)("div",{})," o un componente ",(0,a.jsx)("code",{children:"<MyComponent />"}),"."]}),(0,a.jsxs)("li",{children:[(0,a.jsx)("strong",{children:"Arrays y fragmentos"}),": Los fragmentos (",(0,a.jsx)(a.Fragment,{}),") ya los discutimos con anterioridad, los cuales nos permiten retornar m\xfaltiples elementos si la necesidad de retornar un elemento root concreto, por otro lado, es posible retornar un array con m\xfaltiples elementos."]}),(0,a.jsxs)("li",{children:[(0,a.jsx)("strong",{children:"Portales"}),"Los portales proporcionan una opci\xf3n de primera clase para renderizar hijos en un nodo DOM que existe por fuera de la jerarqu\xeda del DOM del componente padre. Puedes ver m\xe1s de los portales en la documentaci\xf3n oficial."]}),(0,a.jsxs)("li",{children:[(0,a.jsx)("strong",{children:"String y n\xfameros"}),"Estos son renderizados como nodos de texto en el DOM."]}),(0,a.jsxs)("li",{children:[(0,a.jsx)("strong",{children:"Booleanos o nulos"}),"No renderizan nada, pero es utilizado como estrategia para impedir que el componente se muestre si alguna condici\xf3n no se cumple."]})]}),(0,a.jsx)("p",{children:"La funci\xf3n tiene el siguiente formato:"}),(0,a.jsx)(p.Z,{language:"javascript",children:"render(){  \n    // Vars and logic secci\xf3n  \n    return (  \n    //JSX section  \n    )  \n} "}),(0,a.jsx)("p",{children:"Podemos dividir el m\xe9todo en dos partes, el cuerpo del m\xe9todo y el retorno, la primera parte (l\xednea 2), nos permite declarar variables, hacer validaciones, llamadas a m\xe9todos, o cualquier instrucci\xf3n JavaScript v\xe1lida, en segundo lugar tenemos el return (l\xednea 4), donde podemos retornar cualquier de los posibles valores que ya explicamos."}),(0,a.jsx)("p",{children:"La funci\xf3n render debe ser pura, lo que significa que no deber\xe1 modifica el estado del componente, devuelve el mismo resultado cada vez que se invoca con los mismos par\xe1metros y no interact\xfaa directamente con el navegador."}),(0,a.jsx)(c.Z,{title:"Error com\xfan",children:(0,a.jsx)("p",{children:"Actualizar el estado desde la funci\xf3n render puede provocar que el componente se cicle, en un renderizado infinito, ya que cada actualizaci\xf3n del estado dispara nuevamente el m\xe9todo render."})}),(0,a.jsx)(c.Z,{title:"Error com\xfan",children:(0,a.jsx)("p",{children:"Se debo de evitarse intentar interactuar con el DOM desde el m\xe9todo render, ya que en este punto los elementos no han sido renderizados en pantalla, por lo tanto, no existen en el navegador."})}),(0,a.jsxs)("p",{children:["Finalmente, la funci\xf3n render no ser\xe1 invocado si ",(0,a.jsx)("code",{children:"shouldComponentUpdate"})," devuelve falso (hablaremos de esta funci\xf3n m\xe1s adelante)."]}),(0,a.jsx)(c.Z,{title:"Importante",children:(0,a.jsx)("p",{children:"La funci\xf3n render se ejecutar\xe1 cada vez que el state o las props del componente cambien, lo que significa que se puede ejecutar muchas veces durante todo su ciclo de vida."})}),(0,a.jsx)("h2",{children:"Function getSnapshotBeforeUpdate"}),(0,a.jsxs)("p",{children:["Seg\xfan la documentaci\xf3n oficial de React, la funci\xf3n ",(0,a.jsx)("code",{children:"getSnapshotBeforeUpdate"})," se invoca justo antes de que la salida renderizada m\xe1s reciente se entregue. Permite al componente capturar cierta informaci\xf3n del DOM (por ejemplo, la posici\xf3n del scroll) antes de que se cambie potencialmente. Cualquier valor que se devuelva en este ciclo de vida se pasar\xe1 como par\xe1metro al m\xe9todo ",(0,a.jsx)("code",{children:"componentDidUpdate"}),"."]}),(0,a.jsxs)("p",{children:["Dicho de otra forma, este m\xe9todo nos permite recuperar cierta informaci\xf3n del componente justo antes de que se actualice en pantalla, de esta forma, podemos mandar lo que encontramos como par\xe1metro al m\xe9todo ",(0,a.jsx)("code",{children:"componentDidUpdate"})," para hacer alguna acci\xf3n."]}),(0,a.jsx)(p.Z,{language:"javascript",children:"getSnapshotBeforeUpdate(prevProps, prevState) {  \n    if (prevProps.list.length < this.props.list.length) {  \n        const list = this.listRef.current;  \n        return list.scrollHeight - list.scrollTop;  \n    }  \n    return null;  \n    }  \n    \n    componentDidUpdate(prevProps, prevState, snapshot) {  \n    if (snapshot !== null) {  \n        const list = this.listRef.current;  \n        list.scrollTop = list.scrollHeight - snapshot;  \n    }  \n} "}),(0,a.jsxs)("p",{children:["Observa que la funci\xf3n ",(0,a.jsx)("code",{children:"getSnapshotBeforeUpdate"})," retorna un valor, el cual es pasado como par\xe1metro a ",(0,a.jsx)("code",{children:"componentDidUpdate"})," (l\xednea 9)."]}),(0,a.jsx)("p",{children:"Este es quiz\xe1s el m\xe9todo m\xe1s complicado de entender y quiz\xe1s el menos utilizado de todos, por lo que es probable que no lo utilices en un largo tiempo, pero vale la pena que al menos comprendas el concepto. "}),(0,a.jsx)(c.Z,{title:"Importante",children:(0,a.jsxs)("p",{children:["La funci\xf3n ",(0,a.jsx)("code",{children:"getSnapshotBeforeUpdate"})," se ejecutar\xe1 justo despu\xe9s del m\xe9todo render pero antes de que los cambios sean reflejados en el navegador."]})}),(0,a.jsx)("h2",{children:"Function componentDidMount"}),(0,a.jsxs)("p",{children:["La funci\xf3n ",(0,a.jsx)("code",{children:"componentDidMount()"})," se ejecuta justo despu\xe9s del m\xe9todo ",(0,a.jsx)("code",{children:"render()"}),", cuando el componente ya ha sido montado y todos los elementos del DOM ya est\xe1n disponibles, y es utilizado para cargar datos del servidor o para realizar operaciones que requieren elementos del DOM. En este punto todos los elementos ya existen en el DOM y pueden ser accedidos."]}),(0,a.jsx)(p.Z,{language:"javascript",children:"componentDidMount(){  \n    //Any action  \n} "}),(0,a.jsx)("p",{children:"En esta funci\xf3n es seguro modificar el estado o cargar datos del servidor."}),(0,a.jsx)(c.Z,{title:"Importante",children:(0,a.jsx)("p",{children:"La funci\xf3n componentDidMount solo se ejecuta una sola vez durante todo el ciclo de vida de un componente."})}),(0,a.jsx)("h2",{children:"Function componentWillReceiveProps (deprecated)"}),(0,a.jsxs)("p",{children:["La funci\xf3n ",(0,a.jsx)("code",{children:"componentWillReceiveProps(nextProps)"})," se invoca cada vez que un componente ya montado, recibe nuevas propiedades. Este m\xe9todo no se ejecuta durante el montaje inicial."]}),(0,a.jsxs)("p",{children:["Recibe la variable nextProps que contiene los valores de las nuevas propiedades, por lo que es posible comparar los nuevos valores (nextProps) contra los props actuales (",(0,a.jsx)("code",{children:"this.props"}),") para determinar si tenemos que realizar alguna acci\xf3n para actualizar el componente."]}),(0,a.jsx)(p.Z,{language:"javascript",children:"UNSAFE_componentWillReceiveProps(nextProps){  \n    // Any action  \n} "}),(0,a.jsx)("p",{children:"Hay que tener en cuenta que esta funci\xf3n se puede llamar incluso si no ha habido ning\xfan cambio en las props, por ejemplo, cuando el componente padre es actualizado."}),(0,a.jsx)("p",{children:"Este m\xe9todo es utilizado con frecuencia cuando el estado del componente depende de las propiedades, lo que nos permite actualizar el estado cuando las propiedades del componente cambien."}),(0,a.jsx)(c.Z,{title:"Importante",children:(0,a.jsx)("p",{children:"Recordemos que este m\xe9todo fue deprecado a partir de React 16.3, por lo que no deber\xedamos utilizarlo m\xe1s, sin embargo, si se llegara a utilizar, deber\xe1 de llevar el prefijo UNSAFE_."})}),(0,a.jsx)(c.Z,{title:"Importante",children:(0,a.jsx)("p",{children:"La funci\xf3n componentWillReceiveProps se ejecuta cada vez que las propiedades de un componente ya montado cambien, lo que significa que se puede ejecutar varias veces durante todo su ciclo de vida."})}),(0,a.jsx)("h2",{children:"Function shouldComponentUpdate"}),(0,a.jsxs)("p",{children:["La funci\xf3n ",(0,a.jsx)("code",{children:"shouldComponentUpdate(nextProps, nextState)"})," se ejecuta justo antes de la funci\xf3n ",(0,a.jsx)("code",{children:"render()"})," y se utiliza para determinar si un componente requiere ser actualizado. Por default, este m\xe9todo siempre retorna true, lo que significa que el m\xe9todo render se ejecutar\xe1 siempre que el state o las props cambien."]}),(0,a.jsx)("p",{children:"Esta funci\xf3n existe \xfanicamente para mejorar el performance de un componente, permiti\xe9ndole determinar si el m\xe9todo render debe de ser ejecutado o no, incluso si el state o las props cambien. "}),(0,a.jsx)("p",{children:"Esta funci\xf3n recibe las nuevas propiedades (nextProps) y el nuevo estado (nextState) y deber\xe1 de retornar forzosamente un valor booleano, donde un true le indica a React que el m\xe9todo render deber\xe1 ser ejecutado, en otro caso, el m\xe9todo render ser\xe1 omitido y el componente no se actualizar\xe1. "}),(0,a.jsx)(p.Z,{language:"javascript",children:"shouldComponentUpdate(nextProps, nextState) {  \n    // Any action  \n    return boolean  \n} "}),(0,a.jsx)(c.Z,{title:"Error com\xfan",children:(0,a.jsx)("p",{children:"Cabe mencionar que seg\xfan la misma documentaci\xf3n oficial de React, este m\xe9todo es solo una recomendaci\xf3n, por lo que devolver false, puede incluso dar como resultado una nueva renderizaci\xf3n del componente."})}),(0,a.jsx)(c.Z,{title:"Importante",children:(0,a.jsxs)("p",{children:["La funci\xf3n ",(0,a.jsx)("code",{children:"shouldComponentUpdate"})," se ejecutar\xe1 cada vez que el state o las props del componente cambien, por lo que es posible que se ejecute varias veces durante todo el ciclo de vida del componente."]})}),(0,a.jsx)("h2",{children:"Function forceUpdate"}),(0,a.jsxs)("p",{children:["La funci\xf3n ",(0,a.jsx)("code",{children:"forceUpdate"})," no en realidad un m\xe9todo del ciclo de vida de un componente, m\xe1s bien es un m\xe9todo que tiene todos los componentes para forzar la actualizaci\xf3n del componente, brinc\xe1ndose el m\xe9todo ",(0,a.jsx)("code",{children:"shouldComponentUpdate"})," y pasando directo al m\xe9todo render."]}),(0,a.jsx)(p.Z,{language:"javascript",children:"someMethod() {  \n    // Forzar la actualizaci\xf3n  \n    this.forceUpdate();  \n}"}),(0,a.jsx)("p",{children:"Este m\xe9todo puede ser llamado desde cualquier parte del componente, provocando que el m\xe9todo render se ejecuta, incluso si las propiedades y el estado no cambiaron."}),(0,a.jsx)("p",{children:"Este es un m\xe9todo de emergencia, cuando por alguna raz\xf3n no logramos que el componte se actualice cuando queremos, por lo que lo debemos de utilizar con cuidado, y en su lugar debemos de procurar ajustarnos al ciclo de vida normal de React. "}),(0,a.jsx)(c.Z,{title:"Importante",children:(0,a.jsx)("p",{children:"La funci\xf3n forceUpdate jam\xe1s se ejecuta como parte del ciclo de vida de un componente en React, sino m\xe1s bien, es llamado bajo demanda por el mismo programador en caso extremos."})}),(0,a.jsx)("h2",{children:"Function componentWillUpdate (deprecated)"}),(0,a.jsxs)("p",{children:["La funci\xf3n ",(0,a.jsx)("code",{children:"componentWillUpdate(nextProps, nextState)"})," se ejecuta antes de la funci\xf3n ",(0,a.jsx)("code",{children:"render()"})," cuando se reciben nuevas propiedades o estado. Se utiliza para preparar el componente antes de la actualizaci\xf3n. Este m\xe9todo no se llama durante el montado inicial del componente."]}),(0,a.jsxs)("p",{children:["Tenga en cuenta que no se puede llamar a ",(0,a.jsx)("code",{children:"this.setState()"})," desde aqu\xed. En caso de requerir actualizar el estado en respuesta a un cambio en las propiedades, entonces deber\xe1 utilizar el m\xe9todo ",(0,a.jsx)("code",{children:"componentWillReceiveProps()"}),"."]}),(0,a.jsx)(p.Z,{language:"javascript",children:"componentWillUpdate(nextProps, nextState) {  \n    // Any action  \n}  "}),(0,a.jsxs)("p",{children:["La funci\xf3n ",(0,a.jsx)("code",{children:"componentWillUpdate()"})," no ser\xe1 invocado si la funci\xf3n ",(0,a.jsx)("code",{children:"shouldComponentUpdate()"})," retorna false."]}),(0,a.jsx)(c.Z,{title:"Importante",children:(0,a.jsx)("p",{children:"Recordemos que este m\xe9todo fue deprecado a partir de React 16.3, por lo que no deber\xedamos utilizarlo m\xe1s, sin embargo, si se llegara a utilizar, deber\xe1 de llevar el prefijo UNSAFE_. "})}),(0,a.jsx)(c.Z,{title:"Importante",children:(0,a.jsx)("p",{children:"La funci\xf3n componentWillUpdate se ejecuta previo siempre que el state o las props del componte cambien, siempre y cuando el m\xe9todo shouldComponentUpdate retorne true, por lo que se puede ejecutar varias veces durante todo el ciclo de vida del componente."})}),(0,a.jsx)("h2",{children:"Function componentDidUpdate"}),(0,a.jsxs)("p",{children:["La funci\xf3n ",(0,a.jsx)("code",{children:"componentDidUpdate(prevProps, prevState)"})," se ejecuta justo despu\xe9s del m\xe9todo ",(0,a.jsx)("code",{children:"render()"}),", pero solo cuando es actualizado, lo que implica que no ser\xe1 invocado durante la fase de montaje. "]}),(0,a.jsxs)("p",{children:["Esta funci\xf3n recibe como par\xe1metro el estado anterior, las propiedades anteriores y el snapshot generado por la funci\xf3n ",(0,a.jsx)("code",{children:"getSnapshotBeforeUpdate"}),", y se utiliza para realizar operaciones sobre los elementos del DOM o para consumir recursos de red, im\xe1genes o servicios del API, sin embargo, es necesario validar el nuevo estado y props contra los anteriores, para determinar si es necesario realizar alguna acci\xf3n."]}),(0,a.jsx)(p.Z,{language:"javascript",children:"componentDidUpdate(prevProps, prevState, snapshot ){    \n// Any action    \n    if (this.props.userID !== prevProps.userID) {  \n    APIInvoke.invokeGET()  \n    }  \n} "}),(0,a.jsx)("p",{children:"Este servicio se utiliza a menudo para hacer referencia a elementos del DOM una vez que ya est\xe1n disponibles, por otra parte, tambi\xe9n es utilizado para consultar recursos en la red, como es el caso del API, sin embargo, es importante siempre validar el state y las props para asegurarse de que realmente algo cambio para justificar la b\xfasqueda en la red."}),(0,a.jsx)(c.Z,{title:"Importante",children:(0,a.jsxs)("p",{children:["La funci\xf3n ",(0,a.jsx)("code",{children:"componentDidUpdate"})," se ejecuta siempre que el estado o las propiedades sean actualizadas, con la condici\xf3n de que el m\xe9todo ",(0,a.jsx)("code",{children:"shouldComponenteUpdate"})," retorne true. Esto quiere decir que este m\xe9todo se puede ejecutar varias veces durante todo el ciclo de vida de los componentes."]})}),(0,a.jsx)("h2",{children:"Function componentWillUnmount"}),(0,a.jsxs)("p",{children:["La funci\xf3n ",(0,a.jsx)("code",{children:"componentWillUnmount()"})," se invoca inmediatamente antes de que un componente sea desmontado y destruido. Se utiliza para realizar tareas de limpieza, como invalidar temporizadores, cancelar solicitudes de red o limpiar cualquier elemento del DOM. Esta funci\xf3n no recibe ning\xfan par\xe1metro."]}),(0,a.jsx)(p.Z,{language:"javascript",children:"componentWillUnmount() {  \n    // Any action  \n}  "}),(0,a.jsx)("p",{children:"Actualizar el estado en este m\xe9todo ser\xe1 en vano, pues el componente nunca m\xe1s ser\xe1 renderizado."}),(0,a.jsx)(c.Z,{title:"Importante",children:(0,a.jsxs)("p",{children:["La funci\xf3n ",(0,a.jsx)("code",{children:"componentWillUnmount"})," solo se ejecuta una sola vez durante todo el ciclo de vida de un componente."]})}),(0,a.jsx)("h2",{children:"Flujos de montado de un componente"}),(0,a.jsx)("p",{children:"En esta secci\xf3n se describe el ciclo de vida por el cual pasa un componente cuando es montado por primera vez. Se dice que un componente es montado cuando es creado inicialmente y mostrado por primera vez en pantalla."}),(0,a.jsxs)("figure",{children:[(0,a.jsx)(r(),{width:"939",height:"610",src:"/figures/react/ciclo-de-vida-montaje.png",alt:"Ciclo de vida del montaje de un componente."}),(0,a.jsx)("figcaption",{children:"Ciclo de vida del montaje de un componente."})]}),(0,a.jsx)("p",{children:"Cuando un componente es montado inicialmente, siempre se ejecutar\xe1 el constructor de la clase, pues el componente no existe en ese momento. El constructor lo podemos utilizar para inicializar el estado y realizar operaciones de carga de servicios. Cabe mencionar que el constructor no es precisamente parte del ciclo de vida del componente, sino m\xe1s bien es una caracter\xedstica de los lenguajes orientados a objetos, como es el caso de JavaScript."}),(0,a.jsxs)("p",{children:["Justo antes de que el componente sea renderizado, el m\xe9todo ",(0,a.jsx)("code",{children:"getDerivedStateFromProps"})," es ejecutado, con la intenci\xf3n de actualizar el estado basado en las propiedades. Recordemos que este m\xe9todo regresa el nuevo estado del componte o null para dejar el estado actual."]}),(0,a.jsxs)("p",{children:["El siguiente paso es la renderizaci\xf3n del componente mediante el m\xe9todo ",(0,a.jsx)("code",{children:"render()"}),". En este momento son creados los elementos en el DOM y el componente es mostrado en pantalla. En este punto no debemos actualizar el estado mediante ",(0,a.jsx)("code",{children:"setState()"}),", pues podemos ciclar en una actualizaci\xf3n sin fin."]}),(0,a.jsxs)("p",{children:["Una vez que React ha terminado de renderizar el componente mediante ",(0,a.jsx)("code",{children:"render()"}),", ejecuta la funci\xf3n componentDidMount para darle la oportunidad a la aplicaci\xf3n de realizar operaciones sobre los elementos del DOM. En este punto es recomendable realizar carga de datos o simplemente actualizar elementos directamente sobre el DOM."]}),(0,a.jsx)("h2",{children:"Flujos de actualizaci\xf3n"}),(0,a.jsxs)("p",{children:["El flujo de actualizaci\xf3n de un componente se dispara cuando se actualiza el estado mediante ",(0,a.jsx)("code",{children:"this.setState()"}),", pero tambi\xe9n las propiedades entrantes pueden detonar en la actualizaci\xf3n, por lo que en ocasiones la actualizaci\xf3n del componente padre, puede detonar en la actualizaci\xf3n del estado en los elementos hijos."]}),(0,a.jsxs)("figure",{children:[(0,a.jsx)(r(),{width:"1071",height:"695",src:"/figures/react/ciclo-de-vida-actualizacion.png",alt:"Ciclo de vida de la actualizaci\xf3n del estado."}),(0,a.jsx)("figcaption",{children:"Ciclo de vida de la actualizaci\xf3n del estado."})]}),(0,a.jsxs)("p",{children:["Justo antes de que el componente sea actualizado, el m\xe9todo ",(0,a.jsx)("code",{children:"getDerivedStateFromProps"})," es ejecutado, con la intenci\xf3n de actualizar el estado basado en las propiedades. Recordemos que este m\xe9todo regresa el nuevo estado del componte o null para dejar el estado actual."]}),(0,a.jsxs)("p",{children:["Cuando React detecta cambios en el estado o las propiedades, lo primero que har\xe1 React ser\xe1 validar si el componente debe ser o no actualizado, para esto, existe la funci\xf3n ",(0,a.jsx)("code",{children:"shouldComponentUpdate"}),". Esta funci\xf3n deber\xe1 retornar true en caso de que el componente requiera una actualizaci\xf3n y false en caso contrario. Si esta funci\xf3n retorna false, el ciclo de vida se detiene y no se ejecuta el resto de los m\xe9todos."]}),(0,a.jsxs)("p",{children:["El siguiente paso es la actualizaci\xf3n del componente en pantalla, mediante la ejecuci\xf3n de la funci\xf3n ",(0,a.jsx)("code",{children:"render()"}),", en este punto los elementos son creados en el DOM. "]}),(0,a.jsxs)("p",{children:["Entre que el m\xe9todo render termina y los cambios son reflejados en el navegador, el m\xe9todo ",(0,a.jsx)("code",{children:"getSnapshotBeforeUpdate"})," es ejecutado, con la intenci\xf3n de obtener datos relevantes del DOM actual vs el nuevo DOM para pasar estos datos relevantes al m\xe9todo ",(0,a.jsx)("code",{children:"componentDidUpdate"})," como par\xe1metros."]}),(0,a.jsxs)("p",{children:["Una vez que el componente es actualizado y los elementos ya son visibles en el navegador, se ejecuta la funci\xf3n ",(0,a.jsx)("code",{children:"componentDidUpdate"}),", el cual permite realizar carga de datos o realizar operaciones que requiera de la existencia de los elementos en el DOM. Recordemos que este m\xe9todo recibe el snapshot de ",(0,a.jsx)("code",{children:"getSnapshotBeforeUpdate"}),"."]}),(0,a.jsx)("h2",{children:"Flujos de desmontaje de un componente"}),(0,a.jsx)("p",{children:"El ciclo de vida de desmontaje se activa cuando un componente ya no es requerido m\xe1s y requiere ser eliminado. El desmontaje se pueda dar por ejemplo cuando un componente es eliminado de una lista o un componente es remplazado por otro."}),(0,a.jsxs)("figure",{children:[(0,a.jsx)(r(),{width:"1071",height:"315",src:"/figures/react/ciclo-de-vida-desmontaje.png",alt:"Ciclo de vida del desmontaje de un componente."}),(0,a.jsx)("figcaption",{children:"Ciclo de vida del desmontaje de un componente."})]}),(0,a.jsxs)("p",{children:["El ciclo de vida de desmontaje es el m\xe1s simple, pues solo se ejecuta la funci\xf3n ",(0,a.jsx)("code",{children:"componenteWillUnmount"}),", que es utilizada para realizar alguna limpieza o eliminar alg\xfan elemento del DOM antes de que el componente sea destruido."]}),(0,a.jsx)(l.Z,{}),(0,a.jsx)("small",{className:"reserve",children:"Todos los derechos reservados \xa9"})]})})]});o.default=u}},function(e){e.O(0,[1664,5675,9544,7518,9774,2888,179],function(){return e(e.s=50061)}),_N_E=e.O()}]);